# mysql Crud operation commands 

# command to check the version of mysql 

use admin ;
db.system.version.find();


# to see the users details 
 db.system.users.find();



# to check the logs detail 

use local;
switched to db local
> db.startup_log.find();

# command to see collections 

show collections 


# to see all the DB's 

show dbs

# to see currently connected DB 

db

#Create DATABASES -:
Use -: swtiching between DB's / also it create new db if name not exist 
						
#Create COLLECTIONS
db.createCollection("product")
 { "ok" : 1 }
# Since this collection we create under the test DB so now show dbs command will show test DB as well

show collections
product

# Namespace -: always mongo DB refer collection as dbname.collectionName


#command to retrive the Data 
> db.DakshEmployee.find();





                            # insert collections 



Db.collection_name.insert({ })  -:it will insert one records 

Db.collection_name.insert([{ },{}])  -:it will insert multiple records 


db.DakshEmployee.insert(
[ {
	"Emp_id": 6,
	"Emp_name": "kiran",
	"Company": "JK mines",
	"phone_no ": 9571561238,
	"email ": "kiran34 @gmail.com ",
	"salary ": 14000
}, 
{
	"Emp_id ": 5,
	"Emp_name": "jai",
	"Company": "jk mines ",
	"phone_no": "n / a ",
	"email": "jai7 @gmail.com ",
	"salary": 700
}
] )



# User defined value of _ID column (could be anything except array)

> db.product.insert({_id:"09ET402013",prod_name:"motorola",price:1500,availability:"coming soon"})
   WriteResult({ "nInserted" : 1 })
{ "_id" : "09ET402013", "prod_name" : "motorola", "price" : 1500, "availability" : "coming soon" }


# Entering dupicate value of _ID will throw duplicate error

> db.product.insert({_id:"09ET402013",prod_name:"nokia",price:1500,availability:"decomm"})
     WriteResult({
        "nInserted" : 0,
        "writeError" : {
                "code" : 11000,
                "errmsg" : "E11000 duplicate key error collection: test.product index: _id_ dup key: { : \"09ET402013\" }"
        }
})

# Inserting with other value 
> db.product.insert({_id:"09ET402014",prod_name:"nokia",price:1500,availability:"decomm"})
WriteResult({ "nInserted" : 1 })


# Issue with array (error for _ID column )

> db.products.insert({product_name:"daksh",price:4000,_id:[12,32]})
WriteResult({
        "nInserted" : 0,
        "writeError" : {
                "code" : 2,
                "errmsg" : "can't use an array for _id"
        }
})


# we can define the variable and get out by calling the variable 

> var a = db.person.findOne()
> a
{
	"_id" : ObjectId("6181d780156980455d3cf1e5"),
	"name" : {
		"first" : "Harish",
		"last" : "Chandra"
	},
	"gender" : "M",
	"yearOfBirth" : 1962,
	"livesIn" : "Mumbai",
	"countriesVisited" : [
		"India",
		"Singapore",
		"Thailand",
		"United Kingdom",
		"Spain",
		"Denmark",
		"United States of America"
	],
	"languages" : [
		{
			"name" : "Hindi",
			"proficiency" : "Fluent"
		},
		{
			"name" : "English",
			"proficiency" : "Fluent"
		},
		{
			"name" : "Sanskrit",
			"proficiency" : "Intermediate"
		}
	]
}



# insert the multiple records for a variables by passing _id Value 

for(i=1;i<=100;i++)db.newproduct.insert({_id:i ,prod_name: "motorola", price : 1500, availability : "coming soon" })
WriteResult({ "nInserted" : 1 })


# skip the first 2 document and retrive the next 2 document 

> db.person.find().skip(2).limit(2);

#sort the out put based on FirstName and get first 2 document 

> for(i=1;i<=100;i++)db.temp1.insert({event_id:i})
WriteResult({ "nInserted" : 1 })

> db.temp1.find().skip(2).limit(2);
{ "_id" : ObjectId("61a2465b5cdb05bd3b1b7a34"), "event_id" : 3 }
{ "_id" : ObjectId("61a2465b5cdb05bd3b1b7a35"), "event_id" : 4 }

> db.temp1.find().skip(2).limit(2).sort({event_id:1});
{ "_id" : ObjectId("61a2465b5cdb05bd3b1b7a34"), "event_id" : 3 }
{ "_id" : ObjectId("61a2465b5cdb05bd3b1b7a35"), "event_id" : 4 }

> db.temp1.find().skip(2).limit(2).sort({event_id:-1});
{ "_id" : ObjectId("61a2465b5cdb05bd3b1b7a93"), "event_id" : 98 }
{ "_id" : ObjectId("61a2465b5cdb05bd3b1b7a92"), "event_id" : 97 }
> 




                                               ## operators ##


	# $gt -: grater then 
	
	
	Db.persons.find({year:{$gt: 1989}},{_id:0,name:1,year:1})
	
	# $LT Less then 
	
	Db.persons.find({year:{$lt: 1989}},{_id:0,name:1,year:1})
	
	

	# $gt -: grater then equal to
	
	
	Db.persons.find({year:{$gte: 1989}},{_id:0,name:1,year:1})
	
	# Less then equal to
	
	Db.persons.find({year:{$lte: 1989}},{_id:0,name:1,year:1})
	
	
	# EQUAL TO 
	Db.persons.find({year:{$eq: 1989}},{_id:0,name:1,year:1})
	
#	NOT EQUAL TO 
	
Db.persons.find({year:{$ne: 1989}},{_id:0,name:1,year:1})


	
# 	$and  $or $in require [array ]   like 	Where livesin =jaipur or livesin=mumbai
	
	Db.persons.find({ $or: [ {livesin:"Mumbai"} ,{livesin:"jaipur" }] },{_id:0,'name.first':1})
	

# The person who livesIn mumbai or jaipur  and year of birth less then 1980


db.person.find({ $and: [{$or:[ {livesIn:'Mumbai'},{livesIn:'Jaipur'}]},{yearOfBirth:{$lte:1990}}]} ,{_id:0,'name.first':1})
{ "name" : { "first" : "Harish" } }
{ "name" : { "first" : "Narayan" } }
{ "name" : { "first" : "Rita" } }
{ "name" : { "first" : "Neeharika" } }

##   $or operator and $in are not same but if we are fetching same field in condition then both gives same output
	$in is better then $or since it read all document once to satisfy the condition but $or will read twice..
	But if we are fetching 2 different variable  then we have to go with $or


> db.person.find({ $or: [ {'livesIn':'Mumbai'} ,{'livesIn':"Jaipur" }] },{_id:0,'name.first':1})
{ "name" : { "first" : "Harish" } }
{ "name" : { "first" : "Narayan" } }
{ "name" : { "first" : "Rita" } }
{ "name" : { "first" : "Neeharika" } }
> db.person.find({'livesIn':{$in:['Mumbai','Jaipur']}},{"yearOfBirth":1,_id:0,"name":1,livesIn:1});
{ "name" : { "first" : "Harish", "last" : "Chandra" }, "yearOfBirth" : 1962, "livesIn" : "Mumbai" }
{ "name" : { "first" : "Narayan", "last" : "Sundaram" }, "yearOfBirth" : 1960, "livesIn" : "Jaipur" }
{ "name" : { "first" : "Rita", "last" : "Chauhan" }, "yearOfBirth" : 1989, "livesIn" : "Mumbai" }
{ "name" : { "first" : "Neeharika", "last" : "Chauhan" }, "yearOfBirth" : 1988, "livesIn" : "Jaipur" }
> 

/*  $and operator and $all are not same but if we are fetching same field in condition then both gives same output
$all is better then $and since it read all document once to satisfy the condition but $and will read twice..
But if we are fetching 2 different variable  then we have to go with $and 
Generally in nested array where we can use $all operator

*/

> db.person.find({$and :[{livesIn:"Mumbai"},{livesIn:"Jaipur"}]},{"yearOfBirth":1,_id:0,"name":1,livesIn:1});

> db.person.find({livesIn:{$all:["Mumbai","Jaipur"]}},{"yearOfBirth":1,_id:0,"name":1,livesIn:1});
 

		Like operator type scenario then we have to create text index in mongoDB  so we can search a value with entire document in one 
Collection ..



# alterNative to like operator 

# anywhere in string keyword appear 
> db.person.find({First_Name: /Ke/},{First_Name:1})

{ "_id" : ObjectId("61a05c042b878dd893497f57"), "First_Name" : "Ken" }
{ "_id" : ObjectId("61a05c042b878dd893497f67"), "First_Name" : "Kevin" }
{ "_id" : ObjectId("61a05c042b878dd893497f90"), "First_Name" : "Kendall" }

# last word for string will be "en"

> db.person.find({First_Name: /en$/},{First_Name:1})
{ "_id" : ObjectId("61a05c042b878dd893497f57"), "First_Name" : "Ken" }
{ "_id" : ObjectId("61a05c042b878dd893497f9e"), "First_Name" : "Steven" }
{ "_id" : ObjectId("61a05c042b878dd893497fa4"), "First_Name" : "Reuben" }


# last word for string will be "Re"
 
> db.person.find({First_Name: /^Re/},{First_Name:1})
{ "_id" : ObjectId("61a05c042b878dd893497f76"), "First_Name" : "Rebecca" }
{ "_id" : ObjectId("61a05c042b878dd893497fa4"), "First_Name" : "Reuben" }
> 

#  Operators on array document in collection
		
		
for e.g.		Elements of array 
		
		"countriesVisited" :
		[
		"India",   --element 0
		"Singapore",  --element 1
		"Thailand",  --element 2
		"United Kingdom", --element 3
		"Spain", --element 4
		"Denmark", --element 5
		"usa"  --element 6
		]
		
		
		"Dot notation" it always under "" value
		
		"countriesVisited.0"  ----> India
		"countriesVisited.4"  ----> spain


#		Let say find the person who visit first country visit is united kingdom
		
Db.persons.find({"countryvisited.0":"united kingdom"},{_id=0, countryvisited:1})
	
> db.persons.find({"countriesVisited.0": "United Kingdom"},{countriesVisited:1,"name.first":1,_id:0});
 { "name" : { "first" : "Jenny" }, "countriesVisited" : [ "United Kingdom" ] }
{ "name" : { "first" : "Jenny" }, "countriesVisited" : [ "United Kingdom" ] }

# this will display all the records where user visited uk anywhere and anytime
		
> Db.persons.find({"countryvisited":"united kingdom"},{_id=0, countryvisited:1})
		
{ "name" : { "first" : "Harish" }, "countriesVisited" : [ "India", "Singapore", "Thailand", "United Kingdom", "Spain", "Denmark", "United States of America" ] }
{ "name" : { "first" : "Jenny" }, "countriesVisited" : [ "United Kingdom" ] }
{ "name" : { "first" : "Jenny" }, "countriesVisited" : [ "United Kingdom" ] }
{ "name" : { "first" : "Anita" }, "countriesVisited" : [ "India", "United Kingdom", "Canada", "United States of America" ] }


		# Condition of embedded document		Here also embedded document will come in " "
		
		Db.persons.find({"name.first":"harish"},{_id:0,name:1})
		
	# Difference between embeded document and array document
		
	#	In array we put number that is for embedded  after '.' but in embeded document we have to mention key of embedded document .. 



		
		
		# embedded  array 
		
		SUCH LIKE -:
		
		"languages" : [
				{"name" : "Hindi","proficiency" : "Fluent"},
				{"name" : "English","proficiency" : "Fluent"},
				{"name" : "Sanskrit","proficiency" : "Intermediate"}
			        ]
		
		
		
		For example -: 
		
		Person who is know to English and proficiency should be FLUENT
	
		
		The below query gives error since it treat both condition separate BUT FOR SOLUTION BOTH CONDITION SHULD CHECK
		IN SAME ARRAY ELEMENT ...
		
		
		Db.persons.find({$and :[{"languages.name":"english"},{"languages.proeficiency":"fluent"}]},{_id:0,"name.first":1})
		
		
		This  can be solved by elematch  ALSO THERE WILL NOT ANY $AND CONDITION
	  The $elemMatch operator matches documents that contain an array field 
		with at least one element that matches all the specified query criteria.
	
		{ <field>: { $elemMatch: { <query1>, <query2>, ... } } }
	
    db.persons.find({languages:{$elemMatch:{"name":"English","proficiency":"Fluent"}}},{_id:0,languages:1,"name.first":1})
		



                                       # UPDATE

				
to update the keys Name  in document 

	#command to change the field name 
	db.person.update({},{$rename:{"FirstName":"First_Name"}},{multi:true})
	


